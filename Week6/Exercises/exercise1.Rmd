---
title: "R Notebook"
output:
  html_document:
    df_print: paged
---

```{r}

rm(list = ls())

load_mnist <- function() {
  load_image_file <- function(filename) {
    ret = list()
    f = file(filename,'rb')
    readBin(f,'integer',n=1,size=4,endian='big')
    ret$n = readBin(f,'integer',n=1,size=4,endian='big')
    nrow = readBin(f,'integer',n=1,size=4,endian='big')
    ncol = readBin(f,'integer',n=1,size=4,endian='big')
    x = readBin(f,'integer',n=ret$n*nrow*ncol,size=1,signed=F)
    ret$x = matrix(x, ncol=nrow*ncol, byrow=T)
    close(f)
    ret
  }
  load_label_file <- function(filename) {
    f = file(filename,'rb')
    readBin(f,'integer',n=1,size=4,endian='big')
    n = readBin(f,'integer',n=1,size=4,endian='big')
    y = readBin(f,'integer',n=n,size=1,signed=F)
    close(f)
    y
  }
  train <<- load_image_file('mnist/train-images.idx3-ubyte')
  test <<- load_image_file('mnist/t10k-images.idx3-ubyte')
  
  train$y <<- load_label_file('mnist/train-labels.idx1-ubyte')
  test$y <<- load_label_file('mnist/t10k-labels.idx1-ubyte')  
}


show_digit <- function(arr784, col=gray(12:1/12), ...) {
  image(matrix(arr784, nrow=28)[,28:1], col=col, ...)
}

```

```{r}
load_mnist()
#train$y[5]
#show_digit(train$x[5,])
#train$y[6]
#show_digit(train$x[6,])

```
```{r}

train_set <- lapply(train, head, n=5000)
test_set <- lapply(test, head, n=1000)
```

```{r}
# train_set$x[,123]
```

### a)
```{r}

euc_dist <- function(x1, x2) {
	sqrt(sum((x1 - x2) ^ 2))
}


calculate_distances <- function(x1, x2) {
distance_vector <- c() # current vector
all_vectors <-c() # all 5000 vectors
for(i in 1:5000) {
        for(j in 1:1000) {
                distance <- euc_dist (x1[i,], x2[j,])
                distance_vector <- c(distance_vector, distance)
        }
all_vectors <- c(all_vectors, distance_vector)
distance_vector <-c()
}
all_vectors
}


distances <- calculate_distances(train_set$x, test_set$x)
distances[1]
```

```{r}
str(distances)
```

### b)

```{r}
#matrix that has test points as columns and train points as rows

# dist_matrix <- matrix(distances, ncol=1000, nrow=5000, byrow=TRUE)

dist_matrix <- matrix(distances, ncol=1000, nrow=5000, byrow=TRUE)

#Get the list of indices from dist_value_matrix columns (indices point the train data points
#that are nearest to the test data point)
get_indices <- function(k, test, dist_value_matrix) {
  index_list <- list()
  for(i in 1:length(test$y)) {
   k_nn_dist <<- which(dist_value_matrix[,i] %in% sort(dist_value_matrix[,i])[1:k])
   # str(k_nn_dist)
   index_list <- c(index_list, list(k_nn_dist))
  }
  index_list
}

# indexes <- get_indices(5, test_set, dist_matrix)

#Get the vector containing the class values of the points in train data that are nearest
# to the test point (according to indices)
get_nearest_points <-function(k, train, indices) {
        # for loop niin monta kuin indeksejä on
                # for loop niin monta kuin k
class_values <-list()
class_vector <-c()

for(i in 1:length(indices)) {
      for(j in 1:k) {
        index <- indices[[i]][j]
        train$y[index] # selecting 1 from training data that matches index
        class_vector <- c(class_vector, train$y[index])
        }
 class_values <- c(class_values, list(class_vector))
 class_vector <- c()
 }
 class_values

}

# class_values <- get_nearest_points(5, train_set, indexes)


#Get the most common class value among the list of class values (k train data points 
# per each test point
get_most_common_class <- function(class_values) {
  most_common_class <- c()
  for(i in 1:length(class_values)) {
   most_common <<-  names(sort(table(class_values[[i]]), decreasing=TRUE))[1]
   most_common_class <- c(most_common_class, most_common)
  }
  most_common_class
}

# classes_vector <- get_most_common_class(class_values)



#Calculate in how many cases the most common class value is the same as the real class value
# we have from the test data set. 
calculate_accuracy <-function(classes_vector) {
  accuracy_sum <<-0
  for (i in 1:length(classes_vector)) {
    x <<- as.numeric(classes_vector[i])
    if(test_set$y[i]==x) {
      accuracy_sum <<-accuracy_sum +1
    }
  }
  accuracy <- accuracy_sum/length(classes_vector)
}

# accuracy <- calculate_accuracy(classes_vector)


#k-NN -function, returns a vector containing the accuracies of each k points
#k_nn_function <- function(k, train, test, distance_matrix) 

k_nn_function <- function(k, train, test, distance_matrix) {
  accuracy_vector <-c()
  for(i in 1:k) {
    indices <-get_indices(i, test, distance_matrix)
    classes <- get_nearest_points(i, train, indices)
    classes_vector <-get_most_common_class(classes)
    accuracy <- calculate_accuracy(classes_vector)
    accuracy_vector <-c(accuracy_vector, accuracy)
  }
  accuracy_vector
}


results <- k_nn_function(50, train_set, test_set, dist_matrix)



```

```{r}
plot((1:50),results, ylim=c(0.8,1), ylab = "Accuracy", xlab = "k nearest points", pch=21, bg="lightgreen")
```
### 2a)
```{r}
train_set2 <- lapply(train, head, n=500)

str(train_set2)
#60000 training instances and store them in an n×p matrix (where the sample size n = 60000, and the dimension
#p = 784)
np_matrix <- matrix(train_set2$x, ncol=784, nrow=500, byrow=TRUE)
np_matrix_mean <-- np_matrix
str(np_matrix)
#np_mean=mean(np_matrix,'r')
#apply(np_matrix_mean[,1:784], 1, mean)
mean <- colMeans(np_matrix)
#sweep(mean,2,c(0,0,x))
X = t(t(np_matrix) - rep(colMeans(np_matrix), 500))
str(X)
X = t(t(X) / rep(scale(np_matrix)))

covariance = cov(X)

```


